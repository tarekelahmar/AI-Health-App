# Database Migrations Guide

## Migration Rules (Non-Negotiable)

1. ❌ **Never change models without a migration**
2. ✅ **One migration per schema change**
3. ✅ **No manual SQL on production/RDS**
4. ✅ **Always review autogenerated migrations before applying**

## Quick Start

### Create a New Migration

When you modify a model in `app/domain/models/`, create a migration:

```bash
# Using Make (recommended)
make migrate-create MESSAGE="add user phone number field"

# Or using the Python script
python scripts/migrate.py create "add user phone number field"

# Or directly with Alembic
alembic revision --autogenerate -m "add user phone number field"
```

### Apply Migrations

```bash
# Apply all pending migrations
make migrate-upgrade

# Or
python scripts/migrate.py upgrade

# Or
alembic upgrade head
```

### Check Migration Status

```bash
# Show current version
make migrate-current

# Show migration history
make migrate-history
```

## Migration Workflow

### 1. Modify a Model

Edit the model file in `app/domain/models/`:

```python
# app/domain/models/user.py
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    email = Column(String, unique=True, index=True)
    phone = Column(String)  # NEW FIELD
    hashed_password = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
```

### 2. Create Migration

```bash
make migrate-create MESSAGE="add phone field to users table"
```

This will:
- Auto-detect the schema change
- Generate a migration file in `app/migrations/versions/`
- Create upgrade and downgrade functions

### 3. Review the Migration

**Always review the generated migration file!** Check:
- ✅ Correct table/column names
- ✅ Correct data types
- ✅ Indexes and constraints
- ✅ Foreign keys
- ✅ Default values

Example migration file:
```python
def upgrade() -> None:
    op.add_column('users', sa.Column('phone', sa.String(), nullable=True))

def downgrade() -> None:
    op.drop_column('users', 'phone')
```

### 4. Apply Migration

```bash
make migrate-upgrade
```

### 5. Test the Migration

- Verify the schema change in your database
- Test the application with the new schema
- If issues occur, rollback: `make migrate-downgrade`

## Common Commands

### Create Migration
```bash
make migrate-create MESSAGE="description of change"
```

### Apply All Migrations
```bash
make migrate-upgrade
```

### Rollback One Migration
```bash
make migrate-downgrade REVISION="-1"
```

### Rollback to Specific Version
```bash
alembic downgrade <revision_id>
```

### Show Current Version
```bash
make migrate-current
```

### Show History
```bash
make migrate-history
```

## Migration Scripts

### Using Makefile (Recommended)

```bash
make migrate-create MESSAGE="your message"
make migrate-upgrade
make migrate-current
make migrate-history
make migrate-downgrade REVISION="-1"
```

### Using Python Script

```bash
python scripts/migrate.py create "your message"
python scripts/migrate.py upgrade
python scripts/migrate.py current
python scripts/migrate.py history
python scripts/migrate.py downgrade -1
```

### Using Alembic Directly

```bash
alembic revision --autogenerate -m "your message"
alembic upgrade head
alembic current
alembic history
alembic downgrade -1
```

## Best Practices

1. **One Change Per Migration**: Keep migrations focused and atomic
2. **Descriptive Messages**: Use clear, descriptive migration messages
3. **Review Before Applying**: Always review autogenerated migrations
4. **Test Locally First**: Test migrations on local/dev before production
5. **Backup Production**: Always backup production database before migrations
6. **Version Control**: Commit migration files to git
7. **No Manual Changes**: Never modify the database schema manually

## Troubleshooting

### Migration Conflicts

If you have conflicting migrations:
```bash
# Check current state
alembic current

# View history
alembic history

# Resolve conflicts manually in migration files
```

### Autogenerate Not Detecting Changes

If autogenerate doesn't detect your model changes:
1. Ensure all models are imported in `app/migrations/env.py`
2. Check that models inherit from `Base`
3. Verify model is in `app/domain/models/__init__.py`

### Rollback Issues

If you need to rollback:
```bash
# Rollback one step
alembic downgrade -1

# Rollback to specific version
alembic downgrade <revision_id>

# Check what will be rolled back
alembic history --verbose
```

## Production Deployment

### Pre-Deployment Checklist

- [ ] All migrations tested locally
- [ ] Migration files reviewed and committed
- [ ] Database backup created
- [ ] Rollback plan prepared
- [ ] Migration script tested on staging

### Deployment Steps

1. **Backup Database**
   ```bash
   # Create backup before migration
   pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql
   ```

2. **Apply Migrations**
   ```bash
   alembic upgrade head
   ```

3. **Verify**
   ```bash
   alembic current
   # Check application health
   curl http://your-app/health
   ```

4. **Rollback if Needed**
   ```bash
   alembic downgrade -1
   ```

## Migration File Structure

Migration files are located in `app/migrations/versions/` and follow this pattern:

```
<revision_id>_<description>.py
```

Example:
```
0819a425f7fd_initial_schema.py
a1b2c3d4e5f6_add_phone_to_users.py
```

Each migration file contains:
- `revision`: Unique identifier
- `down_revision`: Previous migration ID
- `upgrade()`: Function to apply the migration
- `downgrade()`: Function to rollback the migration

## Pre-commit Hook (Optional)

A pre-commit hook is available to check for model changes without migrations:

```bash
# Install the hook
cp .migration-check.sh .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit
```

This will warn you if you try to commit model changes without creating a migration first.

## Additional Resources

- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [SQLAlchemy Migrations Guide](https://docs.sqlalchemy.org/en/20/core/metadata.html)

## Summary

**Remember the golden rules:**
1. ❌ Never change models without a migration
2. ✅ One migration per schema change  
3. ✅ No manual SQL on production/RDS
4. ✅ Always review autogenerated migrations

**Quick reference:**
- Create: `make migrate-create MESSAGE="your message"`
- Apply: `make migrate-upgrade`
- Check: `make migrate-current`
- History: `make migrate-history`

